package modules.suffixTreeModuleWrapper;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.TreeMap;
import java.util.regex.Pattern;

import common.parallelization.CallbackReceiver;
import modules.CharPipe;
import modules.InputPort;
import modules.ModuleImpl;
import modules.OutputPort;
import models.GstLabelData;

public class LabelDataMergeModule extends modules.ModuleImpl {

	// Variables for the module
	private static final String MODULE_NAME = "LabelDataMergeModule";
	private static final String MODULE_DESCRIPTION = "Merges two outputs of label data generated by the Generalised Suffix "
			+ "Tree Module, assumes that the labels in one input have been reversed.";

	// Variables describing I/O
	private static final String INPUT_LABELS_ID = "labels";
	private static final String INPUT_LABELS_DESC = "[text/csv] Csv rows describing GstLabelData objects.";
	private static final String INPUT_LABELS_REV_ID = "labels reversed";
	private static final String INPUT_LABELS_REV_DESC = "[text/csv] Csv rows describing GstLabelData objects.";
	private static final String OUTPUT_ID = "merged label data";
	private static final String OUTPUT_DESC = "[text/csv] Csv rows describing the merged output of the two inputs.";

	// Pattern to split newlines on
	private static final Pattern NEWLINE_PATTERN = Pattern.compile("\r\n|\n|\r");

	private static final String CSV_HEADER = "label,length,siblings l mean,siblings r mean,siblings mean,children l mean,children r mean,children mean,"
			+ "occurrence l mean,occurrence r mean,occurrence mean,leaves l mean,leaves r mean,leaves mean,levels l mean,levels r mean,levels mean,"
			+ "siblings l,siblings r,children l,children r,occurences l,occurences r,leaves l,leaves r,levels l,levels r";

	public LabelDataMergeModule(CallbackReceiver callbackReceiver, Properties properties) throws Exception {
		super(callbackReceiver, properties);

		// Set the modules name and description
		this.getPropertyDefaultValues().put(ModuleImpl.PROPERTYKEY_NAME, MODULE_NAME);
		this.setDescription(MODULE_DESCRIPTION);

		// Add module category
		this.setCategory("Tree-building");

		// setup input and output ports
		InputPort inputLabelsPort = new InputPort(INPUT_LABELS_ID, INPUT_LABELS_DESC, this);
		inputLabelsPort.addSupportedPipe(CharPipe.class);
		super.addInputPort(inputLabelsPort);

		InputPort inputLabelsReversedPort = new InputPort(INPUT_LABELS_REV_ID, INPUT_LABELS_REV_DESC, this);
		inputLabelsReversedPort.addSupportedPipe(CharPipe.class);
		super.addInputPort(inputLabelsReversedPort);

		OutputPort outputPort = new OutputPort(OUTPUT_ID, OUTPUT_DESC, this);
		outputPort.addSupportedPipe(CharPipe.class);
		super.addOutputPort(outputPort);
	}

	@Override
	public boolean process() throws Exception {

		final InputPort labelsPort = this.getInputPorts().get(INPUT_LABELS_ID);
		final InputPort labelsReversedPort = this.getInputPorts().get(INPUT_LABELS_REV_ID);
		final OutputPort outputPort = this.getOutputPorts().get(OUTPUT_ID);

		final String[] rowsOne = NEWLINE_PATTERN.split(super.readStringFromInputPort(labelsPort));
		final String[] rowsTwo = NEWLINE_PATTERN.split(super.readStringFromInputPort(labelsReversedPort));

		// the input row to start with
		int startRowNo = 2;

		// variables for data objects from the first and second input (text
		// starting l or r)
		GstLabelData left = null;
		GstLabelData right = null;

		// parse rows from the reversed input and add them to a map containing
		// only those labels
		final Map<String, GstLabelData> labelData = new TreeMap<String, GstLabelData>();
		final StringBuilder sb = new StringBuilder();
		for (int i = (startRowNo - 1); i < rowsTwo.length; i++) {
			right = GstLabelData.fromCsv(rowsTwo[i]);

			// re-reverse the label
			sb.append(right.getLabel()).reverse();
			right.setLabel(sb.toString());
			sb.setLength(0);

			labelData.put(right.getLabel(), right);
		}

		// output the header
		outputPort.outputToAllCharPipes(CSV_HEADER + System.lineSeparator());

		// parse rows of the other input, If a label matches one from the
		// re-reversed input, output the merged results.
		for (int i = (startRowNo - 1); i < rowsOne.length; i++) {
			left = GstLabelData.fromCsv(rowsOne[i]);

			// check for a match
			right = labelData.get(left.getLabel());
			if (right != null) {
				// ignore root and single space label
				if (!left.getLabel().isEmpty() && !left.getLabel().equals(" ")) {
					writeCsvLine(left, right, outputPort);
				}
			}
		}

		this.closeAllOutputs();
		return true;
	}

	private void writeCsvLine(GstLabelData left, GstLabelData right, OutputPort outputPort) throws IOException {
		final StringBuilder sb = new StringBuilder();
		sb.append("\"");
		sb.append(left.getLabel());
		sb.append("\",");
		sb.append(right.getLabel().length());
		sb.append(',');

		printListStats(left.getSiblingCounts(), right.getSiblingCounts(), sb);
		sb.append(',');
		printListStats(left.getChildCounts(), right.getChildCounts(), sb);
		sb.append(',');
		printListStats(left.getOccurenceCounts(), right.getOccurenceCounts(), sb);
		sb.append(',');
		printListStats(left.getLeafCounts(), right.getLeafCounts(), sb);
		sb.append(',');
		printListStats(left.getLevels(), right.getLevels(), sb);
		sb.append(',');

		List<List<Integer>> lists = Arrays.asList(left.getSiblingCounts(), right.getSiblingCounts(),
				left.getChildCounts(), right.getChildCounts(), left.getOccurenceCounts(), right.getOccurenceCounts(),
				left.getLeafCounts(), right.getLeafCounts(), left.getLevels(), right.getLevels());

		for (List<Integer> list : lists) {
			printIntList(list, sb);
			sb.append(',');
		}

		sb.setLength(sb.length() - 1);
		sb.append(System.lineSeparator());
		outputPort.outputToAllCharPipes(sb.toString());
	}

	private void printListStats(List<Integer> one, List<Integer> two, StringBuilder sb) {
		final int sumOne = sumList(one);
		final int sumTwo = sumList(two);
		double meanOne = (double) sumOne / one.size();
		double meanTwo = (double) sumTwo / two.size();
		double mean = (double) (sumOne + sumTwo) / (one.size() + two.size());
		sb.append(meanOne);
		sb.append(',');
		sb.append(meanTwo);
		sb.append(',');
		sb.append(mean);
	}

	private int sumList(List<Integer> list) {
		int sum = 0;
		for (int item : list) {
			sum += item;
		}
		return sum;
	}

	private void printIntList(List<Integer> list, StringBuilder sb) {
		for (int i : list) {
			sb.append(i);
			sb.append(" ");
		}
		sb.setLength(sb.length() - 1);
	}

	@Override
	public void applyProperties() throws Exception {
		super.setDefaultsIfMissing();
		super.applyProperties();
	}

}
