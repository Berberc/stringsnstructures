package modules.tree_editing;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.TreeMap;
import java.util.regex.Pattern;

import common.StringUtil;
import common.parallelization.CallbackReceiver;
import modules.CharPipe;
import modules.InputPort;
import modules.ModuleImpl;
import modules.OutputPort;
import models.GstLabelData;

public class LabelDataMergeModule extends modules.ModuleImpl {

	// Variables for the module
	private static final String MODULE_NAME = "LabelDataMergeModule";
	private static final String MODULE_DESCRIPTION = "Merges two outputs of label data generated by the Generalised Suffix "
			+ "Tree Module, assumes that the labels in one input have been reversed.";

	// Variables describing I/O
	private static final String INPUT_LABELS_ID = "labels";
	private static final String INPUT_LABELS_DESC = "[text/csv] Csv rows describing GstLabelData objects.";
	private static final String INPUT_LABELS_REV_ID = "labels reversed";
	private static final String INPUT_LABELS_REV_DESC = "[text/csv] Csv rows describing GstLabelData objects.";
	private static final String OUTPUT_ID = "merged label data";
	private static final String OUTPUT_DESC = "[text/csv] Csv rows describing the merged output of the two inputs.";

	// Pattern to split newlines on
	private static final Pattern NEWLINE_PATTERN = Pattern.compile("\r\n|\n|\r");

	private static final String CSV_HEADER = "label,length,siblings l mean,siblings r mean,siblings mean,children l mean,children r mean,children mean,"
			+ "occurrence l mean,occurrence r mean,occurrence mean,leaves l mean,leaves r mean,leaves mean,levels l mean,levels r mean,levels mean,"
			+ "siblings l,siblings r,children l,children r,occurences l,occurences r,leaves l,leaves r,levels l,levels r";

	// whether and how labels should be trimmed of whitespace, either
	// * do not trim whitespace
	// * trim all whitespace at start and end
	// * trim whitespace only after the label in the direction of reading
	private static enum BlankTrimming {
		NONE, ALL, FOLLOWING
	};

	private static final String PROPERTYKEY_BLANK_TRIM = "Blank Trimming";
	private static final String PROPERTYDESCRIPTION_BLANK_TRIM = "Blanks can be ignored in direction of reading (\"FOLLOWING\", default) or generally (\"ALL\") or not at all (\"NONE\").";
	private BlankTrimming blankTrimming;

	public LabelDataMergeModule(CallbackReceiver callbackReceiver, Properties properties) throws Exception {
		super(callbackReceiver, properties);

		// Set the modules name and description
		this.getPropertyDefaultValues().put(ModuleImpl.PROPERTYKEY_NAME, MODULE_NAME);
		this.setDescription(MODULE_DESCRIPTION);

		// Set default behaviour for whitespace trimming
		this.getPropertyDescriptions().put(PROPERTYKEY_BLANK_TRIM, PROPERTYDESCRIPTION_BLANK_TRIM);
		this.getPropertyDefaultValues().put(PROPERTYKEY_BLANK_TRIM, "FOLLOWING");

		// Add module category
		this.setCategory("Tree-building");

		// setup input and output ports
		InputPort inputLabelsPort = new InputPort(INPUT_LABELS_ID, INPUT_LABELS_DESC, this);
		inputLabelsPort.addSupportedPipe(CharPipe.class);
		super.addInputPort(inputLabelsPort);

		InputPort inputLabelsReversedPort = new InputPort(INPUT_LABELS_REV_ID, INPUT_LABELS_REV_DESC, this);
		inputLabelsReversedPort.addSupportedPipe(CharPipe.class);
		super.addInputPort(inputLabelsReversedPort);

		OutputPort outputPort = new OutputPort(OUTPUT_ID, OUTPUT_DESC, this);
		outputPort.addSupportedPipe(CharPipe.class);
		super.addOutputPort(outputPort);
	}

	@Override
	public boolean process() throws Exception {

		final InputPort labelsPort = this.getInputPorts().get(INPUT_LABELS_ID);
		final InputPort labelsReversedPort = this.getInputPorts().get(INPUT_LABELS_REV_ID);
		final OutputPort outputPort = this.getOutputPorts().get(OUTPUT_ID);

		final String[] rowsLeft = NEWLINE_PATTERN.split(super.readStringFromInputPort(labelsPort));
		final String[] rowsRight = NEWLINE_PATTERN.split(super.readStringFromInputPort(labelsReversedPort));

		// the input row to start with
		int startRowNo = 2;

		// variables for data objects from the first and second input (text
		// reading started left or right)
		GstLabelData dataLeft = null;
		GstLabelData dataRight = null;

		// parse rows from the reversed input and add them to a map
		final Map<String, GstLabelData> labelDataRight = new TreeMap<String, GstLabelData>();
		final StringBuilder sb = new StringBuilder();
		String label = null;
		for (int i = (startRowNo - 1); i < rowsRight.length; i++) {
			dataRight = GstLabelData.fromCsv(rowsRight[i]);

			// re-reverse the label
			label = sb.append(dataRight.getLabel()).reverse().toString();
			sb.setLength(0);
			// trim blanks if ordered to
			switch (this.blankTrimming) {
			case FOLLOWING:
				// left hand side is the end in direction of reading
				label = StringUtil.ltrim(label);
				break;
			case ALL:
				label = label.trim();
				break;
			case NONE:
				break;
			}
			dataRight.setLabel(label);
			addOrMergeDataInMap(dataRight, labelDataRight);
		}

		// parse rows from the normal input, and put them in a map
		final Map<String, GstLabelData> labelDataLeft = new TreeMap<String, GstLabelData>();
		sb.setLength(0);
		label = null;
		for (int i = (startRowNo - 1); i < rowsLeft.length; i++) {
			dataLeft = GstLabelData.fromCsv(rowsLeft[i]);
			switch (this.blankTrimming) {
			case FOLLOWING:
				// right hand side is the end in direction of reading
				label = StringUtil.rtrim(dataLeft.getLabel());
				break;
			case ALL:
				label = dataLeft.getLabel().trim();
				break;
			case NONE:
				label = dataLeft.getLabel();
				break;
			}
			dataLeft.setLabel(label);
			addOrMergeDataInMap(dataLeft, labelDataLeft);
		}

		// output the header
		outputPort.outputToAllCharPipes(CSV_HEADER + System.lineSeparator());

		// traverse the map of labels from the right (often smaller in size)
		// and output all matches with that from the left
		for (final String labelRight : labelDataRight.keySet()) {
			dataRight = labelDataRight.get(labelRight);

			// check for a match
			dataLeft = labelDataLeft.get(labelRight);
			if (dataLeft != null) {
				// ignore root/empty labels
				if (!dataLeft.getLabel().isEmpty() && !dataLeft.getLabel().equals(" ")) {
					writeCsvLine(dataLeft, dataRight, outputPort);
				}
			}
		}

		this.closeAllOutputs();
		return true;
	}

	// adds the labelData to the map and merges it's information with another
	// data object, if one exists for the same label
	// (this is only strictly necessary if whitespace was stripped from some
	// labels as some previously distinct labels might then become identical to
	// other existing labels)
	private void addOrMergeDataInMap(GstLabelData data, Map<String, GstLabelData> map) {
		final GstLabelData other = map.get(data.getLabel());
		if (other != null) {
			data.merge(other);
		}
		map.put(data.getLabel(), data);
	}

	private void writeCsvLine(GstLabelData left, GstLabelData right, OutputPort outputPort) throws IOException {
		final StringBuilder sb = new StringBuilder();
		sb.append("\"");
		sb.append(left.getLabel());
		sb.append("\",");
		sb.append(right.getLabel().length());
		sb.append(',');

		printListStats(left.getSiblingCounts(), right.getSiblingCounts(), sb);
		sb.append(',');
		printListStats(left.getChildCounts(), right.getChildCounts(), sb);
		sb.append(',');
		printListStats(left.getOccurenceCounts(), right.getOccurenceCounts(), sb);
		sb.append(',');
		printListStats(left.getLeafCounts(), right.getLeafCounts(), sb);
		sb.append(',');
		printListStats(left.getLevels(), right.getLevels(), sb);
		sb.append(',');

		List<List<Integer>> lists = Arrays.asList(left.getSiblingCounts(), right.getSiblingCounts(),
				left.getChildCounts(), right.getChildCounts(), left.getOccurenceCounts(), right.getOccurenceCounts(),
				left.getLeafCounts(), right.getLeafCounts(), left.getLevels(), right.getLevels());

		for (List<Integer> list : lists) {
			printIntList(list, sb);
			sb.append(',');
		}

		sb.setLength(sb.length() - 1);
		sb.append(System.lineSeparator());
		outputPort.outputToAllCharPipes(sb.toString());
	}

	private void printListStats(List<Integer> one, List<Integer> two, StringBuilder sb) {
		final int sumOne = sumList(one);
		final int sumTwo = sumList(two);
		double meanOne = (double) sumOne / one.size();
		double meanTwo = (double) sumTwo / two.size();
		double mean = (double) (sumOne + sumTwo) / (one.size() + two.size());
		sb.append(meanOne);
		sb.append(',');
		sb.append(meanTwo);
		sb.append(',');
		sb.append(mean);
	}

	private int sumList(List<Integer> list) {
		int sum = 0;
		for (int item : list) {
			sum += item;
		}
		return sum;
	}

	private void printIntList(List<Integer> list, StringBuilder sb) {
		for (int i : list) {
			sb.append(i);
			sb.append(" ");
		}
		sb.setLength(sb.length() - 1);
	}

	@Override
	public void applyProperties() throws Exception {
		super.setDefaultsIfMissing();

		final String whitespaceBehaviour = this.getProperties().getProperty(PROPERTYKEY_BLANK_TRIM);
		if("ALL".equals(whitespaceBehaviour)) {
			this.blankTrimming = BlankTrimming.ALL;
		} else if("NONE".equals(whitespaceBehaviour)) {
			this.blankTrimming = BlankTrimming.NONE;
		} else {
			this.blankTrimming = BlankTrimming.FOLLOWING;
		}

		super.applyProperties();
	}

}
